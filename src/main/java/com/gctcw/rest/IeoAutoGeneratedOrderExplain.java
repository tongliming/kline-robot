package com.gctcw.rest;

import com.alibaba.fastjson2.JSON;
import com.alibaba.fastjson2.JSONArray;
import com.gctcw.common.KlineParams;
import com.gctcw.persistent.entity.IeoKlinedata;
import com.gctcw.persistent.entity.Ieos;
import com.gctcw.persistent.entity.RobotSetKlineData;
import com.gctcw.service.IeoKlinedataService;
import com.gctcw.service.RobotSetKlineDataService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.time.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

import static java.math.BigDecimal.ROUND_HALF_UP;

/**
 * <p>
 * 定时任务生成IEO币种订单
 * </p>
 *
 * @author gctcw
 * @since 2022-11-17
 */
@Component
@Slf4j
public class IeoAutoGeneratedOrderExplain {
    private Map<Ieos, KlineParams> klineParamsMap = new ConcurrentHashMap<>();
    private Random rand = new Random();
    private final int capacity = 5;
    List<BigDecimal> outerPriceList = new ArrayList<>(capacity);

    private final RobotSetKlineDataService robotSetKlineDataService;
    private final IeoKlinedataService ieoKlinedataService;

    public IeoAutoGeneratedOrderExplain(RobotSetKlineDataService robotSetKlineDataService, IeoKlinedataService ieoKlinedataService) {
        this.robotSetKlineDataService = robotSetKlineDataService;
        this.ieoKlinedataService = ieoKlinedataService;
    }

    public void addKlineParams(Ieos ieos, KlineParams klineParams) {
        this.klineParamsMap.put(ieos, klineParams);
    }

    /**
     * 秒   分   时     日   月   周几
     * <p>
     * 这里是每1min执行一次
     */
    @Scheduled(cron = "0/15 * * * * ?")
    public void orderExplain() {
        String minuteTimeStr = String.valueOf(getEpochSecond());
        klineParamsMap.forEach(
                (ieos, klineParams) -> {
                    outerPriceList.clear();
                    for (int i = 0; i < capacity; i++) {
                        BigDecimal outerPrice = this.getOuterPrice(ieos.getTitle(), klineParams);
                        outerPriceList.add(i, outerPrice);
                    }
                    List<BigDecimal> sortOuterPriceList = outerPriceList.stream()
                            .sorted(Comparator.comparingDouble(BigDecimal::doubleValue))
                            .collect(Collectors.toList());
                    BigDecimal openPrice, closePrice;
                    BigDecimal lowPrice = sortOuterPriceList.get(capacity / 2);
                    BigDecimal highPrice = sortOuterPriceList.get(capacity / 2 + 1);
                    if (rand.nextInt(2) == 0) {
                        openPrice = lowPrice;
                        closePrice = highPrice;
                    } else {
                        closePrice = lowPrice;
                        openPrice = highPrice;
                    }
                    BigDecimal vol = getVol();
                    IeoKlinedata ieoKlinedata = new IeoKlinedata();
                    ieoKlinedata.setPid(ieos.getId());
                    ieoKlinedata.setPrice(openPrice.setScale(8, ROUND_HALF_UP).stripTrailingZeros().toPlainString());
                    ieoKlinedata.setClose(closePrice.setScale(8, ROUND_HALF_UP).stripTrailingZeros().toPlainString());
                    ieoKlinedata.setLow(lowPrice.setScale(8, ROUND_HALF_UP).stripTrailingZeros().toPlainString());
                    ieoKlinedata.setHigh(highPrice.setScale(8, ROUND_HALF_UP).stripTrailingZeros().toPlainString());
                    ieoKlinedata.setVol(vol.stripTrailingZeros().toPlainString());
                    ieoKlinedata.setCtime(minuteTimeStr);
                    ieoKlinedataService.insertOrUpdate(ieoKlinedata);
                }
        );

    }

    /**
     * 获取当前时间时间戳
     * @return
     */
    private long getEpochSecond() {
        LocalDateTime now = LocalDateTime.now();
        LocalDateTime minuteTime = LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(), now.getHour(), now.getMinute());
        return minuteTime.atZone(ZoneId.systemDefault()).toEpochSecond();
    }

    /**
     * 重载今天的K线数据
     */
    public boolean reloadCustomRobotKline(String symbol, KlineParams klineParams) {
        RobotSetKlineData robotData = robotSetKlineDataService.selectTodayKlineDataBySymbol(symbol);
        if (robotData != null) {
            klineParams.setLastDate(LocalDate.now());
            Integer pricePencent = robotData.getPricePencent();
            klineParams.setPricePercent(new BigDecimal(String.valueOf(pricePencent)));
            JSONArray jsonArr = JSON.parseArray(robotData.getKline());
            for (int i = 0; i < jsonArr.size(); i++) {
                JSONArray arr = jsonArr.getJSONArray(i);
                klineParams.getKlinePriceArr()[arr.getIntValue(0)] = arr.getBigDecimal(1);
            }
            log.info("K线数据重载成功！");
            return true;
        } else {
            log.info("控盘机器人K线趋势数据缺失，请到后台添加K线");
            return false;
        }
    }

    /**
     * 获取随机价格
     * @param symbol
     * @return
     */
    public BigDecimal getOuterPrice(String symbol, KlineParams klineParams) {
        // 首次或跨天情形，重载新K线数据
        LocalDate nowDate = LocalDate.now();
        int minute = LocalTime.now().getMinute();
        int second = LocalTime.now().getSecond();
        if ((minute % 5 == 0 && second == 0) || !(nowDate.equals(klineParams.getLastDate()))
                || klineParams.getLastDate() == null) {
            if (!this.reloadCustomRobotKline(symbol, klineParams)) {
                // K线数据没有了怎么办。。。根据上次的价格做个随机计算，返回吧
                // 上次价格等于0怎么办
                if (klineParams.getLastPrice().compareTo(BigDecimal.ZERO) == 0) {
                    return BigDecimal.ZERO;
                }
                int noDataRand = rand.nextInt(10);
                int changePercentRand = rand.nextInt(3); //价格在0%到2%之间浮动
                BigDecimal randPercent = BigDecimal.valueOf(changePercentRand).divide(BigDecimal.valueOf(100));
                if (noDataRand > 6) { // 30%的概率增长
                    return klineParams.getLastPrice().add(klineParams.getLastPrice().multiply(randPercent));
                } else {
                    return klineParams.getLastPrice().subtract(klineParams.getLastPrice().multiply(randPercent));
                }
            }
        }
        LocalTime now = LocalTime.now();
        int hours = now.getHour();
        int minutes = now.getMinute();
        int seconds = now.getSecond();

        int totalMinutes = hours * 60 + minutes;
        int totalSeconds = hours * 60 * 60 + minutes * 60 + seconds;
        // 24h一条K线，共96个点，15分钟（900秒）一个点
        int indexStart = totalMinutes / 15;
        int indexEnd = indexStart + 1;
        // 计算当前区间（0~900s)处于第几秒
        int calSeconds = totalSeconds - indexStart * 15 * 60;
        // 计算位于第几分钟
        int temMinuteIndex = calSeconds / 60;
        if (klineParams.getMinuteIndex() == 0) {
            klineParams.setRandPricePercent(klineParams.getPricePercent());
        }
        if (klineParams.getMinuteIndex() != temMinuteIndex) {
            // 每分钟的价格浮动比例做随机处理
            klineParams.setRandPricePercent(BigDecimal.valueOf(rand.nextDouble()).setScale(2, ROUND_HALF_UP).multiply(klineParams.getPricePercent()));
            klineParams.setMinuteIndex(temMinuteIndex);
        }
        // 0 ～ 0.1PI    0.1PI ~ 0.2PI     0.2PI ~0.3PI     0.3PI ~ 0.4PI     0.4PI ~ 0.5PI
        // 此处看起来复杂，其实不难，就是根据当前秒数在这个价格区间内所处的位置去推算价格，并且不是直线上升，而是做了正弦函数的曲线价格
        BigDecimal sinValue = BigDecimal.valueOf(Math.PI).divide(BigDecimal.valueOf(2), 8, ROUND_HALF_UP).multiply(BigDecimal.valueOf(calSeconds).divide(BigDecimal.valueOf(900), 8, ROUND_HALF_UP));

        // 每一轮K线走势随机出一个新的走势
        if (klineParams.getLastIndexStart() != -1 && klineParams.getLastIndexStart() != indexStart) {
            klineParams.setTendIndex(this.rand.nextInt(5)); // 新周期随机出一种策略出来
        }
        // 根据随机策略生成K线
        sinValue = this.tendGenerateType(sinValue, klineParams.getTendIndex());
        BigDecimal calPrice = klineParams.getKlinePriceArr()[indexStart].subtract(
                (klineParams.getKlinePriceArr()[indexStart].subtract(
                        klineParams.getKlinePriceArr()[indexEnd]
                    ).divide(
                        BigDecimal.valueOf(900), 8, ROUND_HALF_UP
                    ).multiply(
                        BigDecimal.valueOf(calSeconds)
                    )
                ).multiply(BigDecimal.valueOf(Math.sin(sinValue.doubleValue())))
        );
        // 计算出一个比较平滑的曲线价格后，不能直接成为最终价格，因为过于平滑的价格曲线显然让K线不是那么好看
        // 因此，此处再对价格进行一个随机化处理，对当前价格做一个基于“价格浮动比例”的随机升降
        // 升或者降的概率是不同的，价格处于升势的时候，当前价格有60%的概率上涨，价格处于降势下，当前价格有40%概率上涨
        int tendType = klineParams.getKlinePriceArr()[indexStart].compareTo(klineParams.getKlinePriceArr()[indexEnd]) > 0 ? 1 : 0;
        BigDecimal priceRandSeed = BigDecimal.valueOf(rand.nextDouble()).multiply(klineParams.getRandPricePercent());
        // 价格增减随机百分比
        BigDecimal percentRandValue = priceRandSeed.divide(BigDecimal.valueOf(250), 8, ROUND_HALF_UP);
        if (tendType == 1) { // 下降趋势
            if (rand.nextInt(60) > 55) {
                calPrice = calPrice.add(calPrice.multiply(percentRandValue));
            } else {
                calPrice = calPrice.subtract(calPrice.multiply(percentRandValue));
            }
        } else {            // 上升趋势
            if (rand.nextInt(60) > 5) {
                calPrice = calPrice.add(calPrice.multiply(percentRandValue));
            } else {
                calPrice = calPrice.subtract(calPrice.multiply(percentRandValue));
            }
        }
        if (calPrice.compareTo(BigDecimal.ZERO) < 0) {
            calPrice = BigDecimal.ZERO;
        }
        klineParams.setLastIndexStart(indexStart);
        klineParams.setLastPrice(calPrice);
        return calPrice;
    }
    // 简单的五种随机策略
    private BigDecimal tendGenerateType(BigDecimal sinValue, int type) {
        BigDecimal pi01 = BigDecimal.valueOf(Math.PI).multiply(BigDecimal.valueOf(0.1));
        BigDecimal pi02 = BigDecimal.valueOf(Math.PI).multiply(BigDecimal.valueOf(0.2));
        BigDecimal pi03 = BigDecimal.valueOf(Math.PI).multiply(BigDecimal.valueOf(0.3));
        BigDecimal pi04 = BigDecimal.valueOf(Math.PI).multiply(BigDecimal.valueOf(0.4));

        if(type == 0) {
            if(sinValue.compareTo(pi01) > 0 && sinValue.compareTo(pi02) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(2)); // 放大2倍增幅
            }
            if(sinValue.compareTo(pi02) > 0 && sinValue.compareTo(pi04) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(0.6));
            }
        }
        if(type == 1) {
            if(sinValue.compareTo(pi02) > 0 && sinValue.compareTo(pi04) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(0.6));
            }
        }
        if(type == 2) {
            if(sinValue.compareTo(pi01) > 0 && sinValue.compareTo(pi03) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(0.5));
            }
        }
        if(type == 3) {
            if(sinValue.compareTo(pi01) > 0 && sinValue.compareTo(pi02) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(2));
            }
        }
        if( type == 4) {
            if(sinValue.compareTo(pi03) > 0 && sinValue.compareTo(pi04) < 0) {
                return sinValue.multiply(BigDecimal.valueOf(0.7));
            }
        }
        return sinValue;
    }

    private BigDecimal getVol() {
            int pow = rand.nextInt(4) + 1;
            int scale = rand.nextInt(3) + 3;
            return BigDecimal.valueOf(rand.nextDouble())
                    .setScale(scale, ROUND_HALF_UP)
                    .multiply(BigDecimal.TEN.pow(pow));
    }


}

